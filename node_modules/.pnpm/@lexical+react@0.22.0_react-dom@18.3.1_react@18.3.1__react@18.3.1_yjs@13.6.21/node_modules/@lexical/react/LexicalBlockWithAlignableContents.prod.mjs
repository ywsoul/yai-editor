/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

import{useLexicalComposerContext as e}from"@lexical/react/LexicalComposerContext";import{$isDecoratorBlockNode as r}from"@lexical/react/LexicalDecoratorBlockNode";import{useLexicalNodeSelection as t}from"@lexical/react/useLexicalNodeSelection";import{mergeRegister as o,$getNearestBlockElementAncestorOrThrow as i}from"@lexical/utils";import{$getSelection as a,$isNodeSelection as l,$isDecoratorNode as m,FORMAT_ELEMENT_COMMAND as c,$getNodeByKey as n,$isRangeSelection as s,COMMAND_PRIORITY_LOW as f,CLICK_COMMAND as u,KEY_DELETE_COMMAND as d,KEY_BACKSPACE_COMMAND as p}from"lexical";import{useRef as x,useCallback as g,useEffect as C}from"react";import{jsx as N}from"react/jsx-runtime";function v({children:v,format:h,nodeKey:y,className:D}){const[F]=e(),[L,j,B]=t(y),K=x(null),b=g((e=>{const r=a();return L&&l(r)&&(e.preventDefault(),F.update((()=>{r.getNodes().forEach((e=>{m(e)&&e.remove()}))}))),!1}),[F,L]);return C((()=>o(F.registerCommand(c,(e=>{if(L){const t=a();if(l(t)){const t=n(y);r(t)&&t.setFormat(e)}else if(s(t)){const o=t.getNodes();for(const t of o)if(r(t))t.setFormat(e);else{i(t).setFormat(e)}}return!0}return!1}),f),F.registerCommand(u,(e=>e.target===K.current&&(e.preventDefault(),e.shiftKey||B(),j(!L),!0)),f),F.registerCommand(d,b,f),F.registerCommand(p,b,f))),[B,F,L,y,b,j]),N("div",{className:[D.base,L?D.focus:null].filter(Boolean).join(" "),ref:K,style:{textAlign:h||void 0},children:v})}export{v as BlockWithAlignableContents};
