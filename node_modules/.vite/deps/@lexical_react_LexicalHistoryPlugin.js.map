{
  "version": 3,
  "sources": ["../../.pnpm/@lexical+history@0.22.0/node_modules/@lexical/history/LexicalHistory.dev.mjs", "../../.pnpm/@lexical+react@0.22.0_react-dom@18.3.1_react@18.3.1__react@18.3.1_yjs@13.6.21/node_modules/@lexical/react/LexicalHistoryPlugin.dev.mjs"],
  "sourcesContent": ["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { mergeRegister } from '@lexical/utils';\nimport { UNDO_COMMAND, COMMAND_PRIORITY_EDITOR, REDO_COMMAND, CLEAR_EDITOR_COMMAND, CLEAR_HISTORY_COMMAND, CAN_REDO_COMMAND, CAN_UNDO_COMMAND, $isRangeSelection, $isTextNode, $isRootNode } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst HISTORY_MERGE = 0;\nconst HISTORY_PUSH = 1;\nconst DISCARD_HISTORY_CANDIDATE = 2;\nconst OTHER = 0;\nconst COMPOSING_CHARACTER = 1;\nconst INSERT_CHARACTER_AFTER_SELECTION = 2;\nconst DELETE_CHARACTER_BEFORE_SELECTION = 3;\nconst DELETE_CHARACTER_AFTER_SELECTION = 4;\nfunction getDirtyNodes(editorState, dirtyLeaves, dirtyElements) {\n  const nodeMap = editorState._nodeMap;\n  const nodes = [];\n  for (const dirtyLeafKey of dirtyLeaves) {\n    const dirtyLeaf = nodeMap.get(dirtyLeafKey);\n    if (dirtyLeaf !== undefined) {\n      nodes.push(dirtyLeaf);\n    }\n  }\n  for (const [dirtyElementKey, intentionallyMarkedAsDirty] of dirtyElements) {\n    if (!intentionallyMarkedAsDirty) {\n      continue;\n    }\n    const dirtyElement = nodeMap.get(dirtyElementKey);\n    if (dirtyElement !== undefined && !$isRootNode(dirtyElement)) {\n      nodes.push(dirtyElement);\n    }\n  }\n  return nodes;\n}\nfunction getChangeType(prevEditorState, nextEditorState, dirtyLeavesSet, dirtyElementsSet, isComposing) {\n  if (prevEditorState === null || dirtyLeavesSet.size === 0 && dirtyElementsSet.size === 0 && !isComposing) {\n    return OTHER;\n  }\n  const nextSelection = nextEditorState._selection;\n  const prevSelection = prevEditorState._selection;\n  if (isComposing) {\n    return COMPOSING_CHARACTER;\n  }\n  if (!$isRangeSelection(nextSelection) || !$isRangeSelection(prevSelection) || !prevSelection.isCollapsed() || !nextSelection.isCollapsed()) {\n    return OTHER;\n  }\n  const dirtyNodes = getDirtyNodes(nextEditorState, dirtyLeavesSet, dirtyElementsSet);\n  if (dirtyNodes.length === 0) {\n    return OTHER;\n  }\n\n  // Catching the case when inserting new text node into an element (e.g. first char in paragraph/list),\n  // or after existing node.\n  if (dirtyNodes.length > 1) {\n    const nextNodeMap = nextEditorState._nodeMap;\n    const nextAnchorNode = nextNodeMap.get(nextSelection.anchor.key);\n    const prevAnchorNode = nextNodeMap.get(prevSelection.anchor.key);\n    if (nextAnchorNode && prevAnchorNode && !prevEditorState._nodeMap.has(nextAnchorNode.__key) && $isTextNode(nextAnchorNode) && nextAnchorNode.__text.length === 1 && nextSelection.anchor.offset === 1) {\n      return INSERT_CHARACTER_AFTER_SELECTION;\n    }\n    return OTHER;\n  }\n  const nextDirtyNode = dirtyNodes[0];\n  const prevDirtyNode = prevEditorState._nodeMap.get(nextDirtyNode.__key);\n  if (!$isTextNode(prevDirtyNode) || !$isTextNode(nextDirtyNode) || prevDirtyNode.__mode !== nextDirtyNode.__mode) {\n    return OTHER;\n  }\n  const prevText = prevDirtyNode.__text;\n  const nextText = nextDirtyNode.__text;\n  if (prevText === nextText) {\n    return OTHER;\n  }\n  const nextAnchor = nextSelection.anchor;\n  const prevAnchor = prevSelection.anchor;\n  if (nextAnchor.key !== prevAnchor.key || nextAnchor.type !== 'text') {\n    return OTHER;\n  }\n  const nextAnchorOffset = nextAnchor.offset;\n  const prevAnchorOffset = prevAnchor.offset;\n  const textDiff = nextText.length - prevText.length;\n  if (textDiff === 1 && prevAnchorOffset === nextAnchorOffset - 1) {\n    return INSERT_CHARACTER_AFTER_SELECTION;\n  }\n  if (textDiff === -1 && prevAnchorOffset === nextAnchorOffset + 1) {\n    return DELETE_CHARACTER_BEFORE_SELECTION;\n  }\n  if (textDiff === -1 && prevAnchorOffset === nextAnchorOffset) {\n    return DELETE_CHARACTER_AFTER_SELECTION;\n  }\n  return OTHER;\n}\nfunction isTextNodeUnchanged(key, prevEditorState, nextEditorState) {\n  const prevNode = prevEditorState._nodeMap.get(key);\n  const nextNode = nextEditorState._nodeMap.get(key);\n  const prevSelection = prevEditorState._selection;\n  const nextSelection = nextEditorState._selection;\n  const isDeletingLine = $isRangeSelection(prevSelection) && $isRangeSelection(nextSelection) && prevSelection.anchor.type === 'element' && prevSelection.focus.type === 'element' && nextSelection.anchor.type === 'text' && nextSelection.focus.type === 'text';\n  if (!isDeletingLine && $isTextNode(prevNode) && $isTextNode(nextNode) && prevNode.__parent === nextNode.__parent) {\n    // This has the assumption that object key order won't change if the\n    // content did not change, which should normally be safe given\n    // the manner in which nodes and exportJSON are typically implemented.\n    return JSON.stringify(prevEditorState.read(() => prevNode.exportJSON())) === JSON.stringify(nextEditorState.read(() => nextNode.exportJSON()));\n  }\n  return false;\n}\nfunction createMergeActionGetter(editor, delay) {\n  let prevChangeTime = Date.now();\n  let prevChangeType = OTHER;\n  return (prevEditorState, nextEditorState, currentHistoryEntry, dirtyLeaves, dirtyElements, tags) => {\n    const changeTime = Date.now();\n\n    // If applying changes from history stack there's no need\n    // to run history logic again, as history entries already calculated\n    if (tags.has('historic')) {\n      prevChangeType = OTHER;\n      prevChangeTime = changeTime;\n      return DISCARD_HISTORY_CANDIDATE;\n    }\n    const changeType = getChangeType(prevEditorState, nextEditorState, dirtyLeaves, dirtyElements, editor.isComposing());\n    const mergeAction = (() => {\n      const isSameEditor = currentHistoryEntry === null || currentHistoryEntry.editor === editor;\n      const shouldPushHistory = tags.has('history-push');\n      const shouldMergeHistory = !shouldPushHistory && isSameEditor && tags.has('history-merge');\n      if (shouldMergeHistory) {\n        return HISTORY_MERGE;\n      }\n      if (prevEditorState === null) {\n        return HISTORY_PUSH;\n      }\n      const selection = nextEditorState._selection;\n      const hasDirtyNodes = dirtyLeaves.size > 0 || dirtyElements.size > 0;\n      if (!hasDirtyNodes) {\n        if (selection !== null) {\n          return HISTORY_MERGE;\n        }\n        return DISCARD_HISTORY_CANDIDATE;\n      }\n      if (shouldPushHistory === false && changeType !== OTHER && changeType === prevChangeType && changeTime < prevChangeTime + delay && isSameEditor) {\n        return HISTORY_MERGE;\n      }\n\n      // A single node might have been marked as dirty, but not have changed\n      // due to some node transform reverting the change.\n      if (dirtyLeaves.size === 1) {\n        const dirtyLeafKey = Array.from(dirtyLeaves)[0];\n        if (isTextNodeUnchanged(dirtyLeafKey, prevEditorState, nextEditorState)) {\n          return HISTORY_MERGE;\n        }\n      }\n      return HISTORY_PUSH;\n    })();\n    prevChangeTime = changeTime;\n    prevChangeType = changeType;\n    return mergeAction;\n  };\n}\nfunction redo(editor, historyState) {\n  const redoStack = historyState.redoStack;\n  const undoStack = historyState.undoStack;\n  if (redoStack.length !== 0) {\n    const current = historyState.current;\n    if (current !== null) {\n      undoStack.push(current);\n      editor.dispatchCommand(CAN_UNDO_COMMAND, true);\n    }\n    const historyStateEntry = redoStack.pop();\n    if (redoStack.length === 0) {\n      editor.dispatchCommand(CAN_REDO_COMMAND, false);\n    }\n    historyState.current = historyStateEntry || null;\n    if (historyStateEntry) {\n      historyStateEntry.editor.setEditorState(historyStateEntry.editorState, {\n        tag: 'historic'\n      });\n    }\n  }\n}\nfunction undo(editor, historyState) {\n  const redoStack = historyState.redoStack;\n  const undoStack = historyState.undoStack;\n  const undoStackLength = undoStack.length;\n  if (undoStackLength !== 0) {\n    const current = historyState.current;\n    const historyStateEntry = undoStack.pop();\n    if (current !== null) {\n      redoStack.push(current);\n      editor.dispatchCommand(CAN_REDO_COMMAND, true);\n    }\n    if (undoStack.length === 0) {\n      editor.dispatchCommand(CAN_UNDO_COMMAND, false);\n    }\n    historyState.current = historyStateEntry || null;\n    if (historyStateEntry) {\n      historyStateEntry.editor.setEditorState(historyStateEntry.editorState, {\n        tag: 'historic'\n      });\n    }\n  }\n}\nfunction clearHistory(historyState) {\n  historyState.undoStack = [];\n  historyState.redoStack = [];\n  historyState.current = null;\n}\n\n/**\n * Registers necessary listeners to manage undo/redo history stack and related editor commands.\n * It returns `unregister` callback that cleans up all listeners and should be called on editor unmount.\n * @param editor - The lexical editor.\n * @param historyState - The history state, containing the current state and the undo/redo stack.\n * @param delay - The time (in milliseconds) the editor should delay generating a new history stack,\n * instead of merging the current changes with the current stack.\n * @returns The listeners cleanup callback function.\n */\nfunction registerHistory(editor, historyState, delay) {\n  const getMergeAction = createMergeActionGetter(editor, delay);\n  const applyChange = ({\n    editorState,\n    prevEditorState,\n    dirtyLeaves,\n    dirtyElements,\n    tags\n  }) => {\n    const current = historyState.current;\n    const redoStack = historyState.redoStack;\n    const undoStack = historyState.undoStack;\n    const currentEditorState = current === null ? null : current.editorState;\n    if (current !== null && editorState === currentEditorState) {\n      return;\n    }\n    const mergeAction = getMergeAction(prevEditorState, editorState, current, dirtyLeaves, dirtyElements, tags);\n    if (mergeAction === HISTORY_PUSH) {\n      if (redoStack.length !== 0) {\n        historyState.redoStack = [];\n        editor.dispatchCommand(CAN_REDO_COMMAND, false);\n      }\n      if (current !== null) {\n        undoStack.push({\n          ...current\n        });\n        editor.dispatchCommand(CAN_UNDO_COMMAND, true);\n      }\n    } else if (mergeAction === DISCARD_HISTORY_CANDIDATE) {\n      return;\n    }\n\n    // Else we merge\n    historyState.current = {\n      editor,\n      editorState\n    };\n  };\n  const unregister = mergeRegister(editor.registerCommand(UNDO_COMMAND, () => {\n    undo(editor, historyState);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(REDO_COMMAND, () => {\n    redo(editor, historyState);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(CLEAR_EDITOR_COMMAND, () => {\n    clearHistory(historyState);\n    return false;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(CLEAR_HISTORY_COMMAND, () => {\n    clearHistory(historyState);\n    editor.dispatchCommand(CAN_REDO_COMMAND, false);\n    editor.dispatchCommand(CAN_UNDO_COMMAND, false);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerUpdateListener(applyChange));\n  return unregister;\n}\n\n/**\n * Creates an empty history state.\n * @returns - The empty history state, as an object.\n */\nfunction createEmptyHistoryState() {\n  return {\n    current: null,\n    redoStack: [],\n    undoStack: []\n  };\n}\n\nexport { createEmptyHistoryState, registerHistory };\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';\nimport { createEmptyHistoryState, registerHistory } from '@lexical/history';\nexport { createEmptyHistoryState } from '@lexical/history';\nimport { useMemo, useEffect } from 'react';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction useHistory(editor, externalHistoryState, delay = 1000) {\n  const historyState = useMemo(() => externalHistoryState || createEmptyHistoryState(), [externalHistoryState]);\n  useEffect(() => {\n    return registerHistory(editor, historyState, delay);\n  }, [delay, editor, historyState]);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction HistoryPlugin({\n  delay,\n  externalHistoryState\n}) {\n  const [editor] = useLexicalComposerContext();\n  useHistory(editor, externalHistoryState, delay);\n  return null;\n}\n\nexport { HistoryPlugin };\n"],
  "mappings": "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",
  "names": []
}
